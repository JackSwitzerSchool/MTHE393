% Script to analyze test signals, isolate noise, and visualize results
% This script processes the signals generated by generateTestSignals.m

clear all;
close all;

% Set up directories
base_dir = 'C:\Users\jacks\Documents\Life\School\3rd Year\W2025\MTHE393\Design\freq_data';
low_freq_dir = fullfile(base_dir, 'low_freq');
high_freq_dir = fullfile(base_dir, 'high_freq');

% Check if directories exist
if ~exist(low_freq_dir, 'dir') || ~exist(high_freq_dir, 'dir')
    error('Signal directories not found. Run generateTestSignals.m first.');
end

% Process each frequency category
categories = {'low_freq', 'high_freq'};
category_dirs = {low_freq_dir, high_freq_dir};
category_titles = {'Low Frequency (0.01 Hz)', 'High Frequency (1000 Hz)'};
category_freqs = [0.01, 1000];

% Create a figure for the final results
figure('Position', [100, 100, 1200, 900], 'Name', 'Signal and Noise Analysis');

% Loop through each category
for cat_idx = 1:length(categories)
    category = categories{cat_idx};
    dir_path = category_dirs{cat_idx};
    title_text = category_titles{cat_idx};
    freq = category_freqs(cat_idx);
    
    fprintf('Processing %s signals...\n', category);
    
    % Get list of files in the directory
    files = dir(fullfile(dir_path, [category, '_iter_*.mat']));
    
    if isempty(files)
        warning('No files found for %s category. Skipping.', category);
        continue;
    end
    
    fprintf('Found %d files for analysis.\n', length(files));
    
    % First pass: determine minimum signal length and load first file to get time values
    min_length = inf;
    time_values = [];
    
    for i = 1:length(files)
        data = load(fullfile(dir_path, files(i).name));
        struct_name = fieldnames(data);
        main_struct = data.(struct_name{1});
        output_struct = main_struct.output;
        
        if i == 1
            time_values = output_struct.time;
        end
        
        min_length = min(min_length, length(output_struct.signal));
    end
    
    fprintf('Minimum signal length: %d samples\n', min_length);
    
    % Truncate time values to minimum length
    time_values = time_values(1:min_length);
    
    % Initialize matrix to hold all signals
    all_signals = zeros(min_length, length(files));
    
    % Load all signals
    for i = 1:length(files)
        data = load(fullfile(dir_path, files(i).name));
        struct_name = fieldnames(data);
        main_struct = data.(struct_name{1});
        output_struct = main_struct.output;
        
        % Truncate signal to minimum length
        all_signals(:, i) = output_struct.signal(1:min_length);
    end
    
    % Calculate average signal
    avg_signal = mean(all_signals, 2);
    
    % Calculate noise for each signal (signal - average)
    noise_signals = all_signals - avg_signal;
    
    % Calculate average noise magnitude
    avg_noise_magnitude = mean(abs(noise_signals), 2);
    
    % Calculate signal-to-noise ratio (SNR)
    signal_power = mean(avg_signal.^2);
    noise_power = mean(mean(noise_signals.^2, 2));
    snr = 10 * log10(signal_power / noise_power);
    
    fprintf('Signal-to-Noise Ratio (SNR): %.2f dB\n', snr);
    
    % Calculate sampling frequency
    Fs = 1/mean(diff(time_values));
    fprintf('Sampling frequency: %.2f Hz\n', Fs);
    
    % Calculate frequency spectrum of average signal and noise
    L = length(avg_signal);
    f = Fs*(0:(L/2))/L;
    
    % FFT of average signal
    Y_avg = fft(avg_signal);
    P2_avg = abs(Y_avg/L);
    P1_avg = P2_avg(1:floor(L/2)+1);
    P1_avg(2:end-1) = 2*P1_avg(2:end-1);
    
    % FFT of average noise magnitude
    Y_noise = fft(avg_noise_magnitude);
    P2_noise = abs(Y_noise/L);
    P1_noise = P2_noise(1:floor(L/2)+1);
    P1_noise(2:end-1) = 2*P1_noise(2:end-1);
    
    % Plot results for this category
    % Row 1: Time domain - original signals, average, and example noise
    subplot(4, 2, cat_idx);
    plot(time_values, all_signals(:,1:min(5,size(all_signals,2))), 'Color', [0.8, 0.8, 0.8], 'LineWidth', 0.5);
    hold on;
    plot(time_values, avg_signal, 'r', 'LineWidth', 2);
    title(sprintf('%s - Original Signals with Average', title_text));
    xlabel('Time (s)');
    ylabel('Amplitude');
    legend('Noisy Signal', 'Noisy Signal', 'Noisy Signal', 'Noisy Signal', 'Noisy Signal', 'Average Signal', 'Location', 'best');
    grid on;
    
    % Row 2: Time domain - isolated noise examples
    subplot(4, 2, cat_idx + 2);
    plot(time_values, noise_signals(:,1:min(5,size(noise_signals,2))), 'LineWidth', 0.5);
    hold on;
    plot(time_values, avg_noise_magnitude, 'k', 'LineWidth', 2);
    title(sprintf('%s - Isolated Noise Components', title_text));
    xlabel('Time (s)');
    ylabel('Amplitude');
    legend('Noise 1', 'Noise 2', 'Noise 3', 'Noise 4', 'Noise 5', 'Avg Noise Magnitude', 'Location', 'best');
    grid on;
    
    % Row 3: Frequency domain - average signal spectrum
    subplot(4, 2, cat_idx + 4);
    if freq < 1
        % For low frequency, use linear scale
        plot(f, P1_avg, 'LineWidth', 1.5);
        xlim([0, min(10*freq, Fs/2)]); % Limit to 10x the signal frequency or Nyquist
    else
        % For high frequency, use log scale
        semilogx(f, P1_avg, 'LineWidth', 1.5);
        xlim([1, Fs/2]);
    end
    title(sprintf('%s - Frequency Spectrum of Average Signal', title_text));
    xlabel('Frequency (Hz)');
    ylabel('Magnitude');
    grid on;
    
    % Row 4: Frequency domain - noise spectrum
    subplot(4, 2, cat_idx + 6);
    if freq < 1
        % For low frequency, use linear scale
        plot(f, P1_noise, 'LineWidth', 1.5);
        xlim([0, min(10*freq, Fs/2)]); % Limit to 10x the signal frequency or Nyquist
    else
        % For high frequency, use log scale
        semilogx(f, P1_noise, 'LineWidth', 1.5);
        xlim([1, Fs/2]);
    end
    title(sprintf('%s - Frequency Spectrum of Noise', title_text));
    xlabel('Frequency (Hz)');
    ylabel('Magnitude');
    grid on;
    
    % Save the results for this category
    save_dir = fullfile(base_dir, 'analysis_results');
    if ~exist(save_dir, 'dir')
        mkdir(save_dir);
    end
    
    save(fullfile(save_dir, [category, '_analysis.mat']), ...
        'time_values', 'avg_signal', 'noise_signals', 'avg_noise_magnitude', ...
        'snr', 'Fs', 'f', 'P1_avg', 'P1_noise');
    
    fprintf('Analysis for %s complete.\n\n', category);
end

% Adjust figure layout
sgtitle('Signal and Noise Analysis for Different Frequencies', 'FontSize', 16);
set(gcf, 'Color', 'w');

% Save the figure
savefig(fullfile(base_dir, 'analysis_results', 'signal_noise_analysis.fig'));
saveas(gcf, fullfile(base_dir, 'analysis_results', 'signal_noise_analysis.png'));

fprintf('Analysis complete! Results saved in %s\n', fullfile(base_dir, 'analysis_results'));

% Create a separate figure for comparing low-pass filtered signals
figure('Position', [150, 150, 1200, 800], 'Name', 'Low-Pass Filter Comparison');

% Try different cutoff frequencies for each category
cutoff_factors = [0.5, 1, 2, 5, 10]; % Multiples of the signal frequency

for cat_idx = 1:length(categories)
    category = categories{cat_idx};
    title_text = category_titles{cat_idx};
    freq = category_freqs(cat_idx);
    
    % Load the analysis results
    load(fullfile(save_dir, [category, '_analysis.mat']), ...
        'time_values', 'avg_signal', 'noise_signals', 'Fs');
    
    % Get a representative noisy signal (first one)
    noisy_signal = avg_signal + noise_signals(:,1);
    
    % Create subplot for this category
    subplot(2, 1, cat_idx);
    
    % Plot original noisy signal
    plot(time_values, noisy_signal, 'Color', [0.7, 0.7, 0.7], 'LineWidth', 0.5);
    hold on;
    
    % Plot true average signal
    plot(time_values, avg_signal, 'k', 'LineWidth', 2);
    
    % Try different cutoff frequencies
    for i = 1:length(cutoff_factors)
        cutoff = freq * cutoff_factors(i);
        
        % Ensure cutoff is within valid range
        cutoff = min(cutoff, Fs/2 - 1);
        
        % Apply low-pass filter
        [b, a] = butter(4, cutoff/(Fs/2), 'low');
        filtered_signal = filtfilt(b, a, noisy_signal);
        
        % Plot filtered signal
        plot(time_values, filtered_signal, 'LineWidth', 1.5);
    end
    
    % Add legend
    legend_entries = {'Noisy Signal', 'True Average'};
    for i = 1:length(cutoff_factors)
        legend_entries{end+1} = sprintf('Cutoff = %.2fÃ—f', cutoff_factors(i));
    end
    legend(legend_entries, 'Location', 'best');
    
    title(sprintf('%s - Low-Pass Filter Comparison', title_text));
    xlabel('Time (s)');
    ylabel('Amplitude');
    grid on;
    
    % For high frequency, zoom in to see details
    if freq > 1
        xlim([0, min(0.01, max(time_values))]);
    end
end

% Save the filter comparison figure
savefig(fullfile(base_dir, 'analysis_results', 'filter_comparison.fig'));
saveas(gcf, fullfile(base_dir, 'analysis_results', 'filter_comparison.png'));

fprintf('Low-pass filter comparison complete!\n');

%% Comprehensive Filter Evaluation to Find Optimal Filter Parameters
fprintf('\n======= COMPREHENSIVE FILTER EVALUATION =======\n');

% Create structure to store results
filter_results = struct();

% Define filter types to test
filter_types = {'butter', 'cheby1', 'cheby2', 'ellip'};
filter_type_names = {'Butterworth', 'Chebyshev Type I', 'Chebyshev Type II', 'Elliptic'};

% Define filter orders to test
filter_orders = [2, 4, 6, 8];

% Define normalized cutoff factors (relative to signal frequency)
% We'll use more cutoff factors for a more detailed analysis
cutoff_factors = [0.5, 0.75, 1, 1.5, 2, 3, 5, 10];

% Initialize results matrix
% Dimensions: [filter_type, filter_order, cutoff_factor, category]
rmse_results = zeros(length(filter_types), length(filter_orders), length(cutoff_factors), length(categories));
rmse_min = inf;
best_params = struct('type', '', 'order', 0, 'cutoff_factor', 0);

% Loop through each category
for cat_idx = 1:length(categories)
    category = categories{cat_idx};
    freq = category_freqs(cat_idx);
    
    fprintf('Evaluating filters for %s signals...\n', category);
    
    % Load the analysis results
    load(fullfile(save_dir, [category, '_analysis.mat']), ...
        'time_values', 'avg_signal', 'noise_signals', 'Fs');
    
    % Get a representative noisy signal (average of first 5)
    noisy_signal = avg_signal + mean(noise_signals(:,1:min(5,size(noise_signals,2))), 2);
    
    % Loop through filter types
    for type_idx = 1:length(filter_types)
        filter_type = filter_types{type_idx};
        filter_name = filter_type_names{type_idx};
        
        fprintf('  Testing %s filters...\n', filter_name);
        
        % Loop through filter orders
        for order_idx = 1:length(filter_orders)
            filter_order = filter_orders(order_idx);
            
            % Loop through cutoff factors
            for cutoff_idx = 1:length(cutoff_factors)
                cutoff_factor = cutoff_factors(cutoff_idx);
                cutoff = freq * cutoff_factor;
                
                % Ensure cutoff is within valid range
                cutoff = min(cutoff, Fs/2 * 0.95); % Stay below Nyquist
                
                % Apply the filter based on type
                try
                    switch filter_type
                        case 'butter'
                            [b, a] = butter(filter_order, cutoff/(Fs/2), 'low');
                        case 'cheby1'
                            [b, a] = cheby1(filter_order, 0.5, cutoff/(Fs/2), 'low');
                        case 'cheby2'
                            [b, a] = cheby2(filter_order, 20, cutoff/(Fs/2), 'low');
                        case 'ellip'
                            [b, a] = ellip(filter_order, 0.5, 20, cutoff/(Fs/2), 'low');
                    end
                    
                    % Apply the filter
                    filtered_signal = filtfilt(b, a, noisy_signal);
                    
                    % Calculate RMSE
                    rmse = sqrt(mean((filtered_signal - avg_signal).^2));
                    
                    % Store result
                    rmse_results(type_idx, order_idx, cutoff_idx, cat_idx) = rmse;
                    
                    % Check if this is better than current best
                    if rmse < rmse_min
                        rmse_min = rmse;
                        best_params.type = filter_type;
                        best_params.type_name = filter_name;
                        best_params.order = filter_order;
                        best_params.cutoff_factor = cutoff_factor;
                        best_params.category = category;
                        best_params.rmse = rmse;
                    end
                    
                catch ME
                    % Some filter configurations might fail
                    fprintf('    Warning: Filter failed - %s, Order %d, Cutoff %.2fÃ—f (%.2f Hz)\n', ...
                        filter_name, filter_order, cutoff_factor, cutoff);
                    rmse_results(type_idx, order_idx, cutoff_idx, cat_idx) = NaN;
                end
            end
        end
    end
end

% Save the filter evaluation results
filter_results.rmse = rmse_results;
filter_results.filter_types = filter_types;
filter_results.filter_type_names = filter_type_names;
filter_results.filter_orders = filter_orders;
filter_results.cutoff_factors = cutoff_factors;
filter_results.categories = categories;
filter_results.best_params = best_params;

save(fullfile(save_dir, 'filter_evaluation_results.mat'), 'filter_results');

fprintf('\nBest filter parameters across all categories:\n');
fprintf('  Filter type: %s\n', best_params.type_name);
fprintf('  Filter order: %d\n', best_params.order);
fprintf('  Cutoff factor: %.2f Ã— signal frequency\n', best_params.cutoff_factor);
fprintf('  Best RMSE: %.6f\n', best_params.rmse);
fprintf('  Best for category: %s\n', best_params.category);

% Create visualizations of filter performance
fprintf('\nCreating filter performance visualizations...\n');

% Find best filter parameters for each category
best_params_by_category = cell(length(categories), 1);

for cat_idx = 1:length(categories)
    category_rmse = rmse_results(:,:,:,cat_idx);
    [min_rmse, min_idx] = min(category_rmse(:));
    [type_idx, order_idx, cutoff_idx] = ind2sub(size(category_rmse), min_idx);
    
    best_params_by_category{cat_idx} = struct(...
        'type', filter_types{type_idx}, ...
        'type_name', filter_type_names{type_idx}, ...
        'order', filter_orders(order_idx), ...
        'cutoff_factor', cutoff_factors(cutoff_idx), ...
        'rmse', min_rmse, ...
        'category', categories{cat_idx} ...
    );
    
    fprintf('Best filter for %s:\n', categories{cat_idx});
    fprintf('  Filter type: %s\n', filter_type_names{type_idx});
    fprintf('  Filter order: %d\n', filter_orders(order_idx));
    fprintf('  Cutoff factor: %.2f Ã— signal frequency\n', cutoff_factors(cutoff_idx));
    fprintf('  RMSE: %.6f\n', min_rmse);
end

% Create a heatmap figure for each category
for cat_idx = 1:length(categories)
    category = categories{cat_idx};
    category_title = category_titles{cat_idx};
    
    figure('Position', [200, 200, 1200, 900], 'Name', sprintf('Filter Performance - %s', category_title));
    
    % Create a subplot for each filter type
    for type_idx = 1:length(filter_types)
        filter_name = filter_type_names{type_idx};
        
        subplot(2, 2, type_idx);
        
        % Extract RMSE data for this filter type and category
        rmse_data = squeeze(rmse_results(type_idx, :, :, cat_idx));
        
        % Create heatmap
        imagesc(rmse_data);
        colormap('jet');
        colorbar;
        
        % Set axis labels
        xlabel('Cutoff Factor');
        ylabel('Filter Order');
        title(sprintf('%s Filter Performance', filter_name));
        
        % Set axis ticks
        xticks(1:length(cutoff_factors));
        xticklabels(arrayfun(@(x) sprintf('%.2f', x), cutoff_factors, 'UniformOutput', false));
        yticks(1:length(filter_orders));
        yticklabels(arrayfun(@(x) num2str(x), filter_orders, 'UniformOutput', false));
        
        % Rotate x-tick labels for better readability
        xtickangle(45);
        
        % Add text annotations for the minimum RMSE
        [min_order_idx, min_cutoff_idx] = find(rmse_data == min(rmse_data(:)), 1);
        text(min_cutoff_idx, min_order_idx, sprintf('  %.4f', rmse_data(min_order_idx, min_cutoff_idx)), ...
            'Color', 'white', 'FontWeight', 'bold');
    end
    
    % Add overall title
    sgtitle(sprintf('Filter Performance for %s Signals', category_title), 'FontSize', 16);
    
    % Save the figure
    savefig(fullfile(save_dir, sprintf('filter_performance_%s.fig', category)));
    saveas(gcf, fullfile(save_dir, sprintf('filter_performance_%s.png', category)));
end

% Create a figure showing the best filter applied to each category
figure('Position', [250, 250, 1200, 800], 'Name', 'Best Filter Performance');

% Loop through each category
for cat_idx = 1:length(categories)
    category = categories{cat_idx};
    title_text = category_titles{cat_idx};
    freq = category_freqs(cat_idx);
    
    % Get best parameters for this category
    best_params_cat = best_params_by_category{cat_idx};
    
    % Load the analysis results
    load(fullfile(save_dir, [category, '_analysis.mat']), ...
        'time_values', 'avg_signal', 'noise_signals', 'Fs');
    
    % Get a representative noisy signal
    noisy_signal = avg_signal + noise_signals(:,1);
    
    % Create subplot for this category
    subplot(2, 1, cat_idx);
    
    % Plot original noisy signal
    plot(time_values, noisy_signal, 'Color', [0.7, 0.7, 0.7], 'LineWidth', 0.5);
    hold on;
    
    % Plot true average signal
    plot(time_values, avg_signal, 'k', 'LineWidth', 1.5);
    
    % Apply the best filter for this category
    cutoff = freq * best_params_cat.cutoff_factor;
    cutoff = min(cutoff, Fs/2 * 0.95); % Stay below Nyquist
    
    switch best_params_cat.type
        case 'butter'
            [b, a] = butter(best_params_cat.order, cutoff/(Fs/2), 'low');
        case 'cheby1'
            [b, a] = cheby1(best_params_cat.order, 0.5, cutoff/(Fs/2), 'low');
        case 'cheby2'
            [b, a] = cheby2(best_params_cat.order, 20, cutoff/(Fs/2), 'low');
        case 'ellip'
            [b, a] = ellip(best_params_cat.order, 0.5, 20, cutoff/(Fs/2), 'low');
    end
    
    % Apply the filter
    filtered_signal = filtfilt(b, a, noisy_signal);
    
    % Apply the overall best filter
    cutoff_best = freq * best_params.cutoff_factor;
    cutoff_best = min(cutoff_best, Fs/2 * 0.95); % Stay below Nyquist
    
    switch best_params.type
        case 'butter'
            [b, a] = butter(best_params.order, cutoff_best/(Fs/2), 'low');
        case 'cheby1'
            [b, a] = cheby1(best_params.order, 0.5, cutoff_best/(Fs/2), 'low');
        case 'cheby2'
            [b, a] = cheby2(best_params.order, 20, cutoff_best/(Fs/2), 'low');
        case 'ellip'
            [b, a] = ellip(best_params.order, 0.5, 20, cutoff_best/(Fs/2), 'low');
    end
    
    % Apply the overall best filter
    filtered_signal_best = filtfilt(b, a, noisy_signal);
    
    % Plot filtered signals
    plot(time_values, filtered_signal, 'r', 'LineWidth', 1.5);
    plot(time_values, filtered_signal_best, 'g', 'LineWidth', 1.5);
    
    % Calculate RMSE for both filters
    rmse_cat_best = sqrt(mean((filtered_signal - avg_signal).^2));
    rmse_overall_best = sqrt(mean((filtered_signal_best - avg_signal).^2));
    
    % Add legend
    legend('Noisy Signal', 'True Average', ...
        sprintf('Best Filter for This Frequency (RMSE: %.4f)', rmse_cat_best), ...
        sprintf('Best Overall Filter (RMSE: %.4f)', rmse_overall_best), ...
        'Location', 'best');
    
    title_str = sprintf('%s - Best Filter Performance\n%s Order %d, Cutoff %.2fÃ—f', ...
        title_text, best_params_cat.type_name, best_params_cat.order, best_params_cat.cutoff_factor);
    title(title_str);
    xlabel('Time (s)');
    ylabel('Amplitude');
    grid on;
    
    % For high frequency, zoom in to see details
    if freq > 1
        xlim([0, min(0.01, max(time_values))]);
    end
end

% Add overall title
sgtitle('Best Filter Performance Comparison', 'FontSize', 16);

% Save the figure
savefig(fullfile(save_dir, 'best_filter_performance.fig'));
saveas(gcf, fullfile(save_dir, 'best_filter_performance.png'));

% Create a universal filter that works well across all frequencies
fprintf('\n======= DEVELOPING UNIVERSAL FILTER =======\n');

% Approach: Use a normalized frequency approach with the best overall filter type and order
universal_filter_type = best_params.type;
universal_filter_order = best_params.order;
universal_cutoff_factor = best_params.cutoff_factor;

fprintf('Universal filter parameters:\n');
fprintf('  Filter type: %s\n', best_params.type_name);
fprintf('  Filter order: %d\n', universal_filter_order);
fprintf('  Cutoff factor: %.2f Ã— signal frequency\n', universal_cutoff_factor);

% Create a figure to demonstrate the universal filter
figure('Position', [300, 300, 1200, 800], 'Name', 'Universal Filter Performance');

% Test the universal filter on both frequency categories
for cat_idx = 1:length(categories)
    category = categories{cat_idx};
    title_text = category_titles{cat_idx};
    freq = category_freqs(cat_idx);
    
    % Load the analysis results
    load(fullfile(save_dir, [category, '_analysis.mat']), ...
        'time_values', 'avg_signal', 'noise_signals', 'Fs');
    
    % Get a representative noisy signal
    noisy_signal = avg_signal + noise_signals(:,1);
    
    % Create subplot for this category
    subplot(2, 1, cat_idx);
    
    % Plot original noisy signal
    plot(time_values, noisy_signal, 'Color', [0.7, 0.7, 0.7], 'LineWidth', 0.5);
    hold on;
    
    % Plot true average signal
    plot(time_values, avg_signal, 'k', 'LineWidth', 1.5);
    
    % Apply the universal filter
    cutoff = freq * universal_cutoff_factor;
    cutoff = min(cutoff, Fs/2 * 0.95); % Stay below Nyquist
    
    switch universal_filter_type
        case 'butter'
            [b, a] = butter(universal_filter_order, cutoff/(Fs/2), 'low');
        case 'cheby1'
            [b, a] = cheby1(universal_filter_order, 0.5, cutoff/(Fs/2), 'low');
        case 'cheby2'
            [b, a] = cheby2(universal_filter_order, 20, cutoff/(Fs/2), 'low');
        case 'ellip'
            [b, a] = ellip(universal_filter_order, 0.5, 20, cutoff/(Fs/2), 'low');
    end
    
    % Apply the filter
    filtered_signal = filtfilt(b, a, noisy_signal);
    
    % Plot filtered signal
    plot(time_values, filtered_signal, 'r', 'LineWidth', 1.5);
    
    % Calculate RMSE
    rmse = sqrt(mean((filtered_signal - avg_signal).^2));
    
    % Add legend
    legend('Noisy Signal', 'True Average', sprintf('Universal Filter (RMSE: %.4f)', rmse), ...
        'Location', 'best');
    
    title_str = sprintf('%s - Universal Filter Performance\n%s Order %d, Cutoff %.2fÃ—f (%.2f Hz)', ...
        title_text, best_params.type_name, universal_filter_order, universal_cutoff_factor, cutoff);
    title(title_str);
    xlabel('Time (s)');
    ylabel('Amplitude');
    grid on;
    
    % For high frequency, zoom in to see details
    if freq > 1
        xlim([0, min(0.01, max(time_values))]);
    end
    
    fprintf('Universal filter RMSE for %s: %.6f\n', category, rmse);
end

% Add overall title
sgtitle('Universal Filter Performance Across Frequencies', 'FontSize', 16);

% Save the figure
savefig(fullfile(save_dir, 'universal_filter_performance.fig'));
saveas(gcf, fullfile(save_dir, 'universal_filter_performance.png'));

% Create a function to apply the universal filter to any signal
fprintf('\nCreating universal filter function...\n');

% Generate the filter function file
fid = fopen(fullfile(base_dir, 'applyUniversalFilter.m'), 'w');
fprintf(fid, '%% Function to apply the optimized universal filter to any signal\n');
fprintf(fid, 'function filtered_signal = applyUniversalFilter(signal, time_values, signal_freq)\n');
fprintf(fid, '    %% This function applies the optimal filter determined by comprehensive analysis\n');
fprintf(fid, '    %% Inputs:\n');
fprintf(fid, '    %%   signal - The signal to be filtered\n');
fprintf(fid, '    %%   time_values - The time values corresponding to the signal\n');
fprintf(fid, '    %%   signal_freq - The fundamental frequency of the signal (in Hz)\n');
fprintf(fid, '    \n');
fprintf(fid, '    %% Calculate sampling frequency\n');
fprintf(fid, '    Fs = 1/mean(diff(time_values));\n');
fprintf(fid, '    \n');
fprintf(fid, '    %% Universal filter parameters\n');
fprintf(fid, '    filter_type = ''%s'';\n', universal_filter_type);
fprintf(fid, '    filter_order = %d;\n', universal_filter_order);
fprintf(fid, '    cutoff_factor = %.4f;\n', universal_cutoff_factor);
fprintf(fid, '    \n');
fprintf(fid, '    %% Calculate cutoff frequency\n');
fprintf(fid, '    cutoff = signal_freq * cutoff_factor;\n');
fprintf(fid, '    cutoff = min(cutoff, Fs/2 * 0.95); %% Stay below Nyquist\n');
fprintf(fid, '    \n');
fprintf(fid, '    %% Create filter based on type\n');
fprintf(fid, '    switch filter_type\n');
fprintf(fid, '        case ''butter''\n');
fprintf(fid, '            [b, a] = butter(filter_order, cutoff/(Fs/2), ''low'');\n');
fprintf(fid, '        case ''cheby1''\n');
fprintf(fid, '            [b, a] = cheby1(filter_order, 0.5, cutoff/(Fs/2), ''low'');\n');
fprintf(fid, '        case ''cheby2''\n');
fprintf(fid, '            [b, a] = cheby2(filter_order, 20, cutoff/(Fs/2), ''low'');\n');
fprintf(fid, '        case ''ellip''\n');
fprintf(fid, '            [b, a] = ellip(filter_order, 0.5, 20, cutoff/(Fs/2), ''low'');\n');
fprintf(fid, '    end\n');
fprintf(fid, '    \n');
fprintf(fid, '    %% Apply the filter\n');
fprintf(fid, '    filtered_signal = filtfilt(b, a, signal);\n');
fprintf(fid, 'end\n');
fclose(fid);

fprintf('Universal filter function created: %s\n', fullfile(base_dir, 'applyUniversalFilter.m'));
fprintf('\nFilter evaluation complete!\n'); 